<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Algorithm::VSM --- A pure-Perl implementation for constructing a Vector
Space Model of a software
library and for using such a model for efficient retrieval of files in
response to search words.</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#can_this_module_be_used_for_general_text_retrieval">CAN THIS MODULE BE USED FOR GENERAL TEXT RETRIEVAL?</a></li>
	<li><a href="#how_does_one_deal_with_very_large_libraries_corpora">HOW DOES ONE DEAL WITH VERY LARGE LIBRARIES/CORPORA?</a></li>
	<li><a href="#estimating_retrieval_performance_with_precision_vs__recall_calculations">ESTIMATING RETRIEVAL PERFORMANCE WITH PRECISION VS. RECALL CALCULATIONS</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#required">REQUIRED</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
	<li><a href="#export">EXPORT</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#installation">INSTALLATION</a></li>
	<li><a href="#thanks">THANKS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>Algorithm::VSM --- A pure-Perl implementation for constructing a Vector
Space Model (VSM) or a Latent Semantic Analysis Model (LSA) of a software
library and for using such a model for efficient retrieval of files in
response to search words.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  # FOR CONSTRUCTING A VSM MODEL FOR RETRIEVAL:</pre>
<pre>
        use Algorithm::VSM;</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;
        my @query = qw/ program listiterator add arraylist args /;
        my $stop_words_file = &quot;stop_words.txt&quot;;  
        my $corpus_vocab_db = &quot;corpus_vocab_db&quot;;
        my $doc_vectors_db  = &quot;doc_vectors_db&quot;; 
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_directory         =&gt; $corpus_dir,
                           corpus_vocab_db          =&gt; $corpus_vocab_db,
                           doc_vectors_db           =&gt; $doc_vectors_db, 
                           stop_words_file          =&gt; $stop_words_file,
                           max_number_retrievals    =&gt; 10,
                           want_stemming            =&gt; 1,  
        #                  debug                    =&gt; 1,
        );
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;display_corpus_vocab();
        $vsm-&gt;display_doc_vectors();
        my $retrievals = $vsm-&gt;retrieve_for_query_with_vsm( \@query );
        $vsm-&gt;display_retrievals( $retrievals );</pre>
<pre>
     The constructor parameter 'corpus_directory' is for naming the root of
     the directory whose VSM model you wish to construct.  The parameters
     'corpus_vocab_db' and 'doc_vectors_db' are for naming disk-based
     databases in which the VSM model will be stored.  Subsequently, these
     databases can be used for much faster retrieval from the same corpus.
     The parameter 'want_stemming' means that you would want the words in
     the documents to be stemmed to their root forms before the VSM model
     is constructed.  Stemming will reduce all words such as 'programming,'
     'programs,' 'program,' etc. to the same root word 'program.'</pre>
<pre>
     The functions display_corpus_vocab() and display_doc_vectors() are
     there only for testing purposes with small corpora.  If you must use
     them for large libraries/corpora, you might wish to redirect the
     output to a file.  The 'debug' option, when turned on, will output a
     large number of intermediate results in the calculation of the model.
     It is best to redirect the output to a file if 'debug' is on.</pre>
<pre>
  # FOR CONSTRUCTING AN LSA MODEL FOR RETRIEVAL:</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;
        my @query = qw/ program listiterator add arraylist args /;
        my $stop_words_file = &quot;stop_words.txt&quot;;
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_directory         =&gt; $corpus_dir,
                           corpus_vocab_db          =&gt; $corpus_vocab_db,
                           doc_vectors_db           =&gt; $doc_vectors_db,
                           lsa_doc_vectors_db       =&gt; $lsa_doc_vectors_db,
                           stop_words_file          =&gt; $stop_words_file,
                           want_stemming            =&gt; 1,
                           lsa_svd_threshold        =&gt; 0.01, 
                           max_number_retrievals    =&gt; 10,
        #                  debug                    =&gt; 1,
        );
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;display_corpus_vocab();           # only on a small corpus
        $vsm-&gt;display_doc_vectors();            # only on a small corpus
        $vsm-&gt;construct_lsa_model();
        my $retrievals = $vsm-&gt;retrieve_for_query_with_lsa( \@query );
        $vsm-&gt;display_retrievals( $retrievals );</pre>
<pre>
    In the calls above, the constructor parameter lsa_svd_threshold
    determines how many of the singular values will be retained after we
    have carried out an SVD decomposition of the term-frequency matrix for
    the documents in the corpus.  Singular values smaller than this
    threshold fraction of the largest value are rejected.  The parameters
    that end in '_db' are for naming the database files in which the LSA
    model will be stored.  We have already mentioned the role played by the
    parameters 'corpus_vocab_db,' and 'doc_vectors_db (see the explanation
    that goes with the previous construct call example).  The database
    related parameter 'lsa_doc_vectors_db' is for naming the file in which
    we will store the reduced-dimensionality document vectors for the LSA
    model.  This would allow fast LSA-based search to be carried out
    subsequently.</pre>
<pre>
  # FOR USING A PREVIOUSLY CONSTRUCTED VSM MODEL FOR RETRIEVAL:</pre>
<pre>
        my @query = qw/ program listiterator add arraylist args /;
        my $corpus_vocab_db = &quot;corpus_vocab_db&quot;;
        my $doc_vectors_db  = &quot;doc_vectors_db&quot;;
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_vocab_db           =&gt; $corpus_vocab_db, 
                           doc_vectors_db            =&gt; $doc_vectors_db,
                           max_number_retrieval s    =&gt; 10,
        #                  debug                     =&gt; 1,
        );
        $vsm-&gt;upload_vsm_model_from_disk();
        $vsm-&gt;display_corpus_vocab();            # only on a small corpus
        $vsm-&gt;display_doc_vectors();             # only on a small corpus
        my $retrievals = $vsm-&gt;retrieve_with_vsm( \@query );
        $vsm-&gt;display_retrievals( $retrievals );</pre>
<pre>
  # FOR USING A PREVIOUSLY CONSTRUCTED LSA MODEL FOR RETRIEVAL:</pre>
<pre>
        my @query = qw/ program listiterator add arraylist args /;
        my $corpus_vocab_db = &quot;corpus_vocab_db&quot;;
        my $doc_vectors_db  = &quot;doc_vectors_db&quot;;
        my $lsa_doc_vectors_db = &quot;lsa_doc_vectors_db&quot;;
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_vocab_db          =&gt; $corpus_vocab_db,
                           doc_vectors_db           =&gt; $doc_vectors_db,
                           lsa_doc_vectors_db       =&gt; $lsa_doc_vectors_db,
                           max_number_retrievals    =&gt; 10,
        #                  debug               =&gt; 1,
        );
        $vsm-&gt;upload_lsa_model_from_disk();
        $vsm-&gt;display_corpus_vocab();          # only on a small corpus
        $vsm-&gt;display_doc_vectors();           # only on a small corpus 
        $vsm-&gt;construct_lsa_model();
        my $retrievals = $vsm-&gt;retrieve_with_lsa( \@query );
        $vsm-&gt;display_retrievals( $retrievals );</pre>
<pre>
  # FOR MEASURING PRECISION VERSUS RECALL FOR VSM:</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;   
        my $stop_words_file = &quot;stop_words.txt&quot;;  
        my $query_file      = &quot;test_queries.txt&quot;;  
        my $relevancy_file   = &quot;relevancy.txt&quot;;   # All relevancy judgments
                                                  # will be stored in this file
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_directory    =&gt; $corpus_dir,
                           stop_words_file     =&gt; $stop_words_file,
                           query_file          =&gt; $query_file,
                           want_stemming       =&gt; 1,
                           relevancy_threshold =&gt; 5, 
                           relevancy_file      =&gt; $relevancy_file, 
        #                  debug               =&gt; 1,
        );</pre>
<pre>
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;estimate_doc_relevancies(&quot;test_queries.txt&quot;);
        $vsm-&gt;display_corpus_vocab();                  # used only for testing
        $vsm-&gt;display_doc_relevancies();               # used only for testing
        $vsm-&gt;precision_and_recall_calculator('vsm');
        $vsm-&gt;display_precision_vs_recall_for_queries();
        $vsm-&gt;display_map_values_for_queries();</pre>
<pre>
      Measuring precision and recall requires a set of queries.  These are
      supplied through the constructor parameter 'query_file'.  The format
      of the this file must be according to the sample file
      'test_queries.txt' in the 'examples' directory.  The module estimates
      the relevancies of the documents to the queries and dumps the
      relevancies in a file named by the 'relevancy_file' constructor
      parameter.  The constructor parameter 'relevancy_threshold' is used
      in deciding which of the documents are considered to be relevant to a
      query.  A document must contain at least the 'relevancy_threshold'
      occurrences of query words in order to be considered relevant to a
      query.</pre>
<pre>
  # FOR MEASURING PRECISION VERSUS RECALL FOR LSA:</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;    
        my $stop_words_file = &quot;stop_words.txt&quot;;  
        my $query_file      = &quot;test_queries.txt&quot;; 
        my $relevancy_file   = &quot;relevancy.txt&quot;;</pre>
<pre>
        my $vsm = Algorithm::VSM-&gt;new( 
                           corpus_directory    =&gt; $corpus_dir,
                           stop_words_file     =&gt; $stop_words_file,
                           query_file          =&gt; $query_file,
                           want_stemming       =&gt; 1,
                           lsa_svd_threshold   =&gt; 0.01,
                           relevancy_threshold =&gt; 5,
                           relevancy_file      =&gt; $relevancy_file,
        #                   debug               =&gt; 1,
        );</pre>
<pre>
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;construct_lsa_model();
        $vsm-&gt;estimate_doc_relevancies(&quot;test_queries.txt&quot;);
        $vsm-&gt;display_doc_relevancies();
        $vsm-&gt;precision_and_recall_calculator('lsa');
        $vsm-&gt;display_precision_vs_recall_for_queries();
        $vsm-&gt;display_map_values_for_queries();</pre>
<pre>
      We have already explained the purpose of the constructor parameter
      'query_file' and about the constraints on the format of queries in
      the file named through this parameter.  As mentioned earlier, the
      module estimates the relevancies of the documents to the queries and
      dumps the relevancies in a file named by the 'relevancy_file'
      constructor parameter.  The constructor parameter
      'relevancy_threshold' is used in deciding which of the documents are
      considered to be relevant to a query.  A document must contain at
      least the 'relevancy_threshold' occurrences of query words in order
      to be considered relevant to a query.  We have previously explained
      the role of the constructor parameter 'lsa_svd_threshold'.</pre>
<pre>
  # FOR MEASURING PRECISION VERSUS RECALL FOR VSM USING FILE-BASED RELEVANCE JUDGMENTS:</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;  
        my $stop_words_file = &quot;stop_words.txt&quot;;
        my $query_file      = &quot;test_queries.txt&quot;;
        my $relevancy_file   = &quot;relevancy.txt&quot;;</pre>
<pre>
        my $vsm = Algorithm::VSM-&gt;new( 
                   corpus_directory    =&gt; $corpus_dir,
                   stop_words_file     =&gt; $stop_words_file,
                   query_file          =&gt; $query_file,
                   want_stemming       =&gt; 1,
                   relevancy_file      =&gt; $relevancy_file,
        #        debug               =&gt; 1,
        );</pre>
<pre>
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;upload_document_relevancies_from_file();  
        $vsm-&gt;display_doc_relevancies();
        $vsm-&gt;precision_and_recall_calculator('vsm');
        $vsm-&gt;display_precision_vs_recall_for_queries();
        $vsm-&gt;display_map_values_for_queries();</pre>
<pre>
    Now the filename supplied through the constructor parameter
    'relevancy_file' must contain relevance judgments for the queries that
    are named in the file supplied through the parameter 'query_file'.  The
    format of these two files must be according to what is shown in the
    sample files 'test_queries.txt' and 'relevancy.txt' in the 'examples'
    directory.</pre>
<pre>
  # FOR MEASURING PRECISION VERSUS RECALL FOR LSA USING FILE-BASED RELEVANCE JUDGMENTS:</pre>
<pre>
        my $corpus_dir = &quot;corpus&quot;;  
        my $stop_words_file = &quot;stop_words.txt&quot;;
        my $query_file      = &quot;test_queries.txt&quot;;
        my $relevancy_file   = &quot;relevancy.txt&quot;;</pre>
<pre>
        my $vsm = Algorithm::VSM-&gt;new( 
                   corpus_directory    =&gt; $corpus_dir,
                   corpus_vocab_db     =&gt; $corpus_vocab_db,
                   doc_vectors_db      =&gt; $doc_vectors_db,
                   stop_words_file     =&gt; $stop_words_file,
                   query_file          =&gt; $query_file,
                   want_stemming       =&gt; 1,
                   lsa_svd_threshold   =&gt; 0.01,
                   relevancy_file      =&gt; $relevancy_file,
        #        debug               =&gt; 1,
        );</pre>
<pre>
        $vsm-&gt;get_corpus_vocabulary_and_word_counts();
        $vsm-&gt;generate_document_vectors();
        $vsm-&gt;display_corpus_vocab();
        $vsm-&gt;display_doc_vectors();
        $vsm-&gt;upload_document_relevancies_from_file();  
        $vsm-&gt;display_doc_relevancies();
        $vsm-&gt;precision_and_recall_calculator('vsm');
        $vsm-&gt;display_precision_vs_recall_for_queries();
        $vsm-&gt;display_map_values_for_queries();</pre>
<pre>
    As mentioned for the previous code block, the filename supplied through
    the constructor parameter 'relevancy_file' must contain relevance
    judgments for the queries that are named in the file supplied through
    the parameter 'query_file'.  The format of this file must be according
    to what is shown in the sample file 'relevancy.txt' in the 'examples'
    directory.  We have already explained the roles played by the
    constructor parameters such as 'lsa_svd_threshold'.</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p><strong>Algorithm::VSM</strong> is a <em>perl5</em> module for constructing a Vector Space
Model (VSM) or a Latent Semantic Analysis Model (LSA) of a collection of
documents, usually referred to as a corpus, and then retrieving the
documents in response to search words in a query.</p>
<p>VSM and LSA models have been around for a long time in the Information
Retrieval (IR) community.  More recently such models have been shown to be
effective in retrieving files/documents from software libraries. For an
account of this research that was presented by Shivani Rao and the author
of this module at the 2011 Mining Software Repositories conference, see
<a href="http://portal.acm.org/citation.cfm?id=1985451">http://portal.acm.org/citation.cfm</a>.</p>
<p>VSM modeling consists of: (1) Extracting the vocabulary used in a corpus.
(2) Stemming the words so extracted and eliminating the designated stop
words from the vocabulary.  Stemming means that closely related words like
'programming' and 'programs' are reduced to the common root word 'program'
and the stop words are the non-discriminating words that can be expected to
exist in virtually all the documents. (3) Constructing document vectors for
the individual files in the corpus --- the document vectors taken together
constitute what is usually referred to as a 'term-frequency' matrix for the
corpus. (4) Constructing a query vector for the search query after the
query is subject to the same stemming and stop-word elimination rules that
were applied to the corpus. And, lastly, (5) Using a similarity metric to
return the set of documents that are most similar to the query vector.  The
commonly used similarity metric is one based on the cosine distance between
two vectors.  Also note that all the vectors mentioned here are of the same
size, the size of the vocabulary extracted from the corpus.  An element of
a vector is the frequency of the occurrence of the word corresponding to
that position in the vector.</p>
<p>LSA modeling is a small variation on VSM modeling.  Now you take VSM
modeling one step further by subjecting the term-frequency matrix for the
corpus to singular value decomposition (SVD).  By retaining only a subset
of the singular values (usually the N largest for some value of N), you can
construct reduced-dimensionality vectors for the documents and the queries.
In VSM, as mentioned above, the size of the document and the query vectors
is equal to the size of the vocabulary.  For large corpora, this size may
involve tens of thousands elements --- this can slow down the VSM modeling
and retrieval process.  So you are very likely to get faster performance
with retrieval based on LSA modeling, especially if you store the model
once constructed in a database file on the disk and carry out retrievals
using the disk-based model.</p>
<p>
</p>
<hr />
<h1><a name="can_this_module_be_used_for_general_text_retrieval">CAN THIS MODULE BE USED FOR GENERAL TEXT RETRIEVAL?</a></h1>
<p>This module has only been tested for software retrieval.  For more general
text retrieval, you would need to replace the simple stemmer used in the
module by one based on, say, Porter's Stemming Algorithm.  You would also
need to vastly expand the list of stop words appropriate to the text
corpora of interest to you. As previously mentioned, the stop words are the
commonly occurring words that do not carry much discriminatory power from
the standpoint of distinguishing between the documents.  See the file
'stop_words.txt' in the 'examples' directory for how such a file must be
formatted.</p>
<p>
</p>
<hr />
<h1><a name="how_does_one_deal_with_very_large_libraries_corpora">HOW DOES ONE DEAL WITH VERY LARGE LIBRARIES/CORPORA?</a></h1>
<p>It is not uncommon for large software libraries to consist of tens of
thousands of documents that include source-code files, documentation files,
README files, configuration files, etc.  The bug-localization work
presented recently by Shivani Rao and this author at the 2011 Mining
Software Repository conference (MSR11) was based on a relatively
small iBUGS dataset involving 6546 documents and a vocabulary size of
7553 unique words. (Here is a link to this work:
<a href="http://portal.acm.org/citation.cfm?id=1985451">http://portal.acm.org/citation.cfm</a>.  Also note that the iBUGS
dataset was originally put together by V. Dallmeier and T. Zimmermann for
the evaluation of automated bug detection and localization tools.)  If <code>V</code>
is the size of the vocabulary and <code>M</code> the number of the documents in the
corpus, the size of each vector will be <code>V</code> and size of the term-frequency
matrix for the entire corpus will be of size <code>V</code>x<code>M</code>.  So if you were to
duplicate the bug localization experiments in
<a href="http://portal.acm.org/citation.cfm?id=1985451">http://portal.acm.org/citation.cfm</a> you would be dealing with
vectors of size 7553 and a term-frequency matrix of size 7553x6546.
Extrapolating these numbers to really large libraries/corpora, we are
obviously talking about very large matrices for SVD decomposition.  For
large libraries/corpora, it would be best to store away the model in a disk
file and to base all subsequent retrievals on the disk-stored models.  The
'examples' directory contains scripts that carry out retrievals on the
basis of disk-based models.  Further speedup in retrieval can be achieved
by using LSA to create reduced-dimensionality representations for the
documents and by basing retrievals on the stored versions of such
reduced-dimensionality representations.</p>
<p>
</p>
<hr />
<h1><a name="estimating_retrieval_performance_with_precision_vs__recall_calculations">ESTIMATING RETRIEVAL PERFORMANCE WITH PRECISION VS. RECALL CALCULATIONS</a></h1>
<p>The performance of a retrieval algorithm is typically measured by two
properties, <code>Precision</code> and <code>Recall</code>, at a given rank <code>r</code>.  As mentioned
in the <a href="http://portal.acm.org/citation.cfm?id=1985451">http://portal.acm.org/citation.cfm</a> publication, at
given rank <code>r</code>, Precision is the ratio of the number of retrieved
documents that are relevant to the total number of retrieved documents up
to that rank.  And, along the same lines, <code>Recall</code> at a given rank <code>r</code> is
the ratio of the number of retrieved documents that are relevant to the
total number of relevant documents.  The area under the
<code>Precision</code>--<code>Recall</code> curve is called the <code>Average Precision</code> for a
query.  When the <code>Average Precision</code> is averaged over all the queries, we
obtain what is known as <code>Mean Average Precision</code> (MAP).  For an oracle,
the value of MAP should be 1.0.  On the other hand, for purely random
retrieval from a corpus, the value of MAP will be inversely proportional to
the size of the corpus.  (See the discussion in
<a href="http://RVL4.ecn.purdue.edu/~kak/SignifanceTesting.pdf">http://RVL4.ecn.purdue.edu/~kak/SignifanceTesting.pdf</a> for further
explanation on these performance evaluators.)  This module includes methods
that allow you to carry out these performance measurements using the
relevancy judgments supplied through a disk file.  If human-supplied
relevancy judgments are not available, the module will be happy to estimate
relevancies for you just by determining the number of query words that
exist in a document.  Note, however, that relevancy judgments estimated in
this manner cannot be trusted. That is because ultimately it is the humans
who are the best judges of the relevancies of documents to queries.  The
humans bring to bear semantic considerations on the relevancy determination
problem that are beyond the scope of this module.</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<p>The module provides the following methods for constructing VSM and LSA
models of a corpus, for using the models thus constructed for retrieval,
and for carrying out precision versus recall calculations for the
determination of retrieval accuracy on the corpora of interest to you.</p>
<dl>
<dt><strong><a name="new" class="item"><strong>new():</strong></a></strong></dt>

<dd>
<p>A call to <a href="#new"><code>new()</code></a> constructs a new instance of the <code>Algorithm::VSM</code>
class:</p>
<pre>
    my $vsm = Algorithm::VSM-&gt;new( 
                     corpus_directory    =&gt; &quot;&quot;,
                     corpus_vocab_db     =&gt; &quot;corpus_vocab_db&quot;,
                     doc_vectors_db      =&gt; &quot;doc_vectors_db&quot;,
                     lsa_doc_vectors_db  =&gt; &quot;lsa_doc_vectors_db&quot;,  
                     stop_words_file     =&gt; &quot;&quot;, 
                     want_stemming       =&gt; 1,
                     min_word_length     =&gt; 4,
                     lsa_svd_threshold   =&gt; 0.01, 
                     query_file          =&gt; &quot;&quot;,  
                     relevancy_threshold =&gt; 5, 
                     relevancy_file      =&gt; $relevancy_file,
                     max_number_retrievals    =&gt; 10,
                     debug               =&gt; 0,
                                 );</pre>
<p>The values shown on the right side of the big arrows are the <strong>default
values for the parameters</strong>.  The following nested list will now describe
each of the constructor parameters:</p>
<dl>
<dt><strong><a name="corpus_directory" class="item"><em>corpus_directory:</em></a></strong></dt>

<dd>
<p>The parameter <strong>corpus_directory</strong> points to the root of the
directory of documents for which you want to create a VSM or LSA model.</p>
</dd>
<dt><strong><a name="corpus_vocab_db" class="item"><em>corpus_vocab_db:</em></a></strong></dt>

<dd>
<p>The parameter <strong>corpus_vocab_db</strong> is for naming the DBM in which the corpus
vocabulary will be stored after it is subject to stemming and the
elimination of stop words.  Once a disk-based VSM model is created and
stored away in the file named by this parameter and the parameter to be
described next, it can subsequently be used directly for speedier
retrieval.</p>
</dd>
<dt><strong><a name="doc_vectors_db" class="item"><em>doc_vectors_db:</em></a></strong></dt>

<dd>
<p>The database named by <strong>doc_vectors_db</strong> stores the document vector
representation for each document in the corpus.  Each document vector has
the same size as the corpus-wide vocabulary; each element of such a vector
is the number of occurrences of the word that corresponds to that position
in the vocabulary vector.</p>
</dd>
<dt><strong><a name="lsa_doc_vectors_db" class="item"><em>lsa_doc_vectors_db</em></a></strong></dt>

<dd>
<p>The database named by <strong>lsa_doc_vectors_db</strong> stores the
reduced-dimensionality vectors for each of the corpus documents.  These
vectors are creating for LSA modeling of a corpus.</p>
</dd>
<dt><strong><a name="stop_words_file" class="item"><em>stop_words_file</em></a></strong></dt>

<dd>
<p>The parameter <strong>stop_words_file</strong> is for naming the file that contains the
stop words that you do not wish to include in the corpus vocabulary.  The
format of this file must be as shown in the sample file <code>stop_words.txt</code>
in the 'examples' directory.</p>
</dd>
<dt><strong><a name="want_stemming" class="item"><em>want_stemming</em></a></strong></dt>

<dd>
<p>The boolean parameter <strong>want_stemming</strong> determines whether or not the words
extracted from the documents would be subject to stemming.  As mentioned
elsewhere, stemming means that related words like 'programming' and
'programs' would both be reduced to the root word 'program'.</p>
</dd>
<dt><strong><a name="min_word_length" class="item"><em>min_word_length</em></a></strong></dt>

<dd>
<p>The parameter <strong>min_word_length</strong> sets the minimum number
of characters in a word in order for it be included in the corpus
vocabulary.</p>
</dd>
<dt><strong><a name="lsa_svd_threshold" class="item"><em>lsa_svd_threshold</em></a></strong></dt>

<dd>
<p>The parameter <strong>lsa_svd_threshold</strong> is used for rejecting
singular values that are smaller than this threshold fraction of the
largest singular value.  This plays a critical role in creating
reduced-dimensionality document vectors in LSA modeling of a corpus.</p>
</dd>
<dt><strong><em>lsa_svd_threshold</em></strong></dt>

<dd>
<p>The parameter <strong>query_file</strong> points to a file that contains the queries to
be used for calculating retrieval performance with <code>Precision</code> and
<code>Recall</code> numbers. The format of the query file must be as shown in the
sample file <code>test_queries.txt</code> in the 'examples' directory.</p>
</dd>
<dt><strong><a name="relevancy_threshold" class="item"><em>relevancy_threshold</em></a></strong></dt>

<dd>
<p>The constructor parameter <strong>relevancy_threshold</strong> is used for automatic
determination of document relevancies to queries on the basis of the number
of occurrences of query words in a document.  You can exercise control over
the process of determining relevancy of a document to a query by giving a
suitable value to the constructor parameter <strong>relevancy_threshold</strong>.  A
document is considered relevant to a query only when the document contains
at least <strong>relevancy_threshold</strong> number of query words.</p>
</dd>
<dt><strong><a name="max_number_retrievals" class="item"><em>max_number_retrievals</em></a></strong></dt>

<dd>
<p>The constructor parameter <strong>max_number_retrievals</strong> stands for what it
means.</p>
</dd>
<dt><strong><a name="debug" class="item"><em>debug</em></a></strong></dt>

<dd>
<p>Finally, when you set the boolean parameter <a href="#debug"><code>debug</code></a>, the module outputs a
very large amount of intermediate results that are generated during model
construction and during matching a query with the document vectors.</p>
</dd>
</dl>
<br></dd>
<dt><strong><a name="get_corpus_vocabulary_and_word_counts" class="item"><strong>get_corpus_vocabulary_and_word_counts():</strong></a></strong></dt>

<dd>
<p>After you have constructed a new instance of the <code>Algorithm::VSM</code> class,
you must now scan the corpus documents for constructing the corpus
vocabulary. This you do by:</p>
<pre>
    $vsm-&gt;get_corpus_vocabulary_and_word_counts();</pre>
<p>The only time you do NOT need to call this method is when you are using a
previously constructed disk-stored VSM or LSA model for retrieval.</p>
</dd>
<dt><strong><a name="display_corpus_vocab" class="item"><strong>display_corpus_vocab():</strong></a></strong></dt>

<dd>
<p>If you would like to see corpus vocabulary as constructed by the previous
call, make the call</p>
<pre>
    $vsm-&gt;display_corpus_vocab();</pre>
<p>Note that this is a useful thing to do only on small test corpora. If you
must call this method on a large corpus, you might wish to direct the
output to a file.  The corpus vocabulary is shown automatically when
<a href="#debug"><code>debug</code></a> option is turned on.</p>
</dd>
<dt><strong><a name="generate_document_vectors" class="item"><strong>generate_document_vectors():</strong></a></strong></dt>

<dd>
<p>This is a necessary step after the vocabulary used by a corpus is
constructed. (Of course, if you will be doing document retrieval through a
disk-stored VSM or LSA model, then you do not need to call this method.
You construct document vectors through the following call:</p>
<pre>
    $vsm-&gt;generate_document_vectors();</pre>
</dd>
<dt><strong><a name="display_doc_vectors" class="item"><strong>display_doc_vectors():</strong></a></strong></dt>

<dd>
<p>If you would like to see the document vectors constructed by the previous
call, make the call:</p>
<pre>
    $vsm-&gt;display_doc_vectors();</pre>
<p>Note that this is a useful thing to do only on small test corpora. If you
must call this method on a large corpus, you might wish to direct the
output to a file.  The document vectors are shown automatically when
<a href="#debug"><code>debug</code></a> option is turned on.</p>
</dd>
<dt><strong><a name="retrieve_with_vsm" class="item"><strong>retrieve_with_vsm():</strong></a></strong></dt>

<dd>
<p>After you have constructed a VSM model, you call this method for document
retrieval for a given query <code>@query</code>.  The call syntax is:</p>
<pre>
    my $retrievals = $vsm-&gt;retrieve_with_vsm( \@query );</pre>
<p>The argument, <code>@query</code>, is simply a list of words that you wish to use for
retrieval. The method returns a hash whose keys are the document names and
whose values the similarity distance between the document and the query.
As is commonly the case with VSM, this module uses the cosine similarity
distance when comparing a document vector with the query vector.</p>
</dd>
<dt><strong><a name="display_retrievals" class="item"><strong>display_retrievals( $retrievals ):</strong></a></strong></dt>

<dd>
<p>You can display the retrieved document names by calling this method using
the syntax:</p>
<pre>
    $vsm-&gt;display_retrievals( $retrievals );</pre>
<p>where <code>$retrievals</code> is a reference to the hash returned by a call to one
of the <code>retrieve</code> methods.  The display method shown here respects the
retrieval size constraints expressed by the constructor parameter
<a href="#max_number_retrievals"><code>max_number_retrievals</code></a>.</p>
</dd>
<dt><strong><a name="construct_lsa_model" class="item"><strong>construct_lsa_model():</strong></a></strong></dt>

<dd>
<p>If after you have extracted the corpus vocabulary and constructed document
vectors, you would do your retrieval with LSA modeling, you need to make
the following call:</p>
<pre>
    $vsm-&gt;construct_lsa_model();</pre>
<p>The SVD decomposition that is carried out in LSA model construction uses
the constructor parameter <a href="#lsa_svd_threshold"><code>lsa_svd_threshold</code></a> to decide how many of the
singular values to retain for the LSA model.  A singular is retained only
if it is larger than the <a href="#lsa_svd_threshold"><code>lsa_svd_threshold</code></a> fraction of the largest
singular value.</p>
</dd>
<dt><strong><a name="retrieve_with_lsa" class="item"><strong>retrieve_with_lsa():</strong></a></strong></dt>

<dd>
<p>After you have built an LSA model through the call to
<a href="#construct_lsa_model"><code>construct_lsa_model()</code></a>, you can retrieve the document names most 
similar to the query by:</p>
<pre>
    my $retrievals = $vsm-&gt;retrieve_with_lsa( \@query );</pre>
<p>Subsequently, you can display the retrievals by calling the
<a href="#display_retrievals"><code>display_retrievals($retrieval)</code></a> method described previously.</p>
</dd>
<dt><strong><a name="upload_vsm_model_from_disk" class="item"><strong>upload_vsm_model_from_disk():</strong></a></strong></dt>

<dd>
<p>When you invoke the methods <a href="#get_corpus_vocabulary_and_word_counts"><code>get_corpus_vocabulary_and_word_counts()</code></a> and
<a href="#generate_document_vectors"><code>generate_document_vectors()</code></a>, that automatically deposits the VSM model
in the database files named with the constructor parameters
<a href="#corpus_vocab_db"><code>corpus_vocab_db</code></a> and <a href="#doc_vectors_db"><code>doc_vectors_db</code></a>.  Subsequently, you can carry out
retrieval by directly using this disk-based VSM model for speedier
performance.  In order to do so, you must upload the disk-based model by</p>
<pre>
    $vsm-&gt;upload_vsm_model_from_disk();</pre>
<p>Subsequently you call</p>
<pre>
    my $retrievals = $vsm-&gt;retrieve_with_vsm( \@query );
    $vsm-&gt;display_retrievals( $retrievals );</pre>
<p>for retrieval and for displaying the results.</p>
</dd>
<dt><strong><a name="upload_lsa_model_from_disk" class="item"><strong>upload_lsa_model_from_disk():</strong></a></strong></dt>

<dd>
<p>When you invoke the methods <a href="#get_corpus_vocabulary_and_word_counts"><code>get_corpus_vocabulary_and_word_counts()</code></a>,
<a href="#generate_document_vectors"><code>generate_document_vectors()</code></a> and <a href="#construct_lsa_model"><code>construct_lsa_model()</code></a>, that
automatically deposits the LSA model in the database files named with the
constructor parameters <a href="#corpus_vocab_db"><code>corpus_vocab_db</code></a>, <a href="#doc_vectors_db"><code>doc_vectors_db</code></a> and
<a href="#lsa_doc_vectors_db"><code>lsa_doc_vectors_db</code></a>.  Subsequently, you can carry out retrieval by
directly using this disk-based LSA model for speedier performance.  In
order to do so, you must upload the disk-based model by</p>
<pre>
    $vsm-&gt;upload_lsa_model_from_disk();</pre>
<p>Subsequently you call</p>
<pre>
    my $retrievals = $vsm-&gt;retrieve_with_lsa( \@query );
    $vsm-&gt;display_retrievals( $retrievals );</pre>
<p>for retrieval and for displaying the results.</p>
</dd>
<dt><strong><a name="estimate_doc_relevancies" class="item"><strong>estimate_doc_relevancies($query_file):</strong></a></strong></dt>

<dd>
<p>Before you can carry out precision and recall calculations to test the
accuracy of VSM and LSA based retrievals from a corpus, you need to have
available the relevancy judgments for the queries.  (A relevancy judgment
for a query is simply the list of documents relevant to that query.)
Relevancy judgments are commonly supplied by the humans who are familiar
with the corpus.  But if such human-supplied relevance judgments are not
available, you can invoke the following method to estimate them:</p>
<pre>
    $vsm-&gt;estimate_doc_relevancies(&quot;test_queries.txt&quot;);</pre>
<p>For the above method call, a document is considered to be relevant to a
query if it contains several of the query words.  As to the minimum number
of query words that must exist in a document in order for the latter to be
considered relevant, that is determined by the <a href="#relevancy_threshold"><code>relevancy_threshold</code></a>
parameter in the VSM constructor.</p>
<p>But note that this estimation of document relevancies to queries is NOT for
serious work.  The reason for that is because ultimately it is the humans
who are the best judges of the relevancies of documents to queries.  The
humans bring to bear semantic considerations on the relevancy determination
problem that are beyond the scope of this module.</p>
<p>The generated relevancies are deposited in a file named by the constructor
parameter <code>relevancy_file</code>.</p>
</dd>
<dt><strong><a name="display_doc_relevancies" class="item"><strong>display_doc_relevancies():</strong></a></strong></dt>

<dd>
<p>If you would like to see the document relevancies generated by the
previous method, you can call</p>
<pre>
    $vsm-&gt;display_doc_relevancies()</pre>
</dd>
<dt><strong><a name="precision_and_recall_calculator" class="item"><strong>precision_and_recall_calculator():</strong></a></strong></dt>

<dd>
<p>After you have created or obtained the relevancy judgments for your test
queries, you can make the following call to calculate <code>Precision@rank</code> and
<code>Recall@rank</code>:</p>
<pre>
    $vsm-&gt;precision_and_recall_calculator('vsm');</pre>
<p>or</p>
<pre>
    $vsm-&gt;precision_and_recall_calculator('lsa');</pre>
<p>depending on whether you are testing VSM-based retrieval or LSA-based
retrieval.</p>
</dd>
<dt><strong><a name="display_precision_vs_recall_for_queries" class="item"><strong>display_precision_vs_recall_for_queries():</strong></a></strong></dt>

<dd>
<p>A call to <a href="#precision_and_recall_calculator"><code>precision_and_recall_calculator()</code></a> will normally be followed
by the following call</p>
<pre>
    $vsm-&gt;display_precision_vs_recall_for_queries();</pre>
<p>for displaying the <code>Precision@rank</code> and <code>Recall@rank</code> values.</p>
</dd>
<dt><strong><a name="display_map_values_for_queries" class="item"><strong>display_map_values_for_queries():</strong></a></strong></dt>

<dd>
<p>The area under the precision vs. recall curve for a given query is called
<code>Average Precision</code> for that query.  When this area is averaged over all
the queries, you get <code>MAP</code> (Mean Average Precision) as a measure of the
accuracy of the retrieval algorithm.  The <code>Average Precision</code> values for
the queries and the overall <code>MAP</code> can be printed out by calling</p>
<pre>
    $vsm-&gt;display_map_values_for_queries();</pre>
</dd>
<dt><strong><a name="upload_document_relevancies_from_file" class="item"><strong>upload_document_relevancies_from_file():</strong></a></strong></dt>

<dd>
<p>When human-supplied relevancies are available, you can upload them
into the program by calling</p>
<pre>
    $vsm-&gt;upload_document_relevancies_from_file();</pre>
<p>These relevance judgments will be read from a file that is named with the
<code>relevancy_file</code> constructor parameter.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="required">REQUIRED</a></h1>
<p>This module requires the following modules:</p>
<pre>
    SDBM_File
    Storable
    PDL
    PDL::IO::Storable</pre>
<p>The first two of these are needed for creating disk-based database records
for the VSM and LSA models.  The third is needed for calculating the SVD of
the term-frequency matrix. (PDL stands for Perl Data Language.)  The last
is needed for disk storage of the reduced-dimensionality vectors produced
during LSA calculations.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>See the 'examples' directory in the distribution for the scripts listed
below:</p>
<dl>
<dt><strong><a name="for_basic_vsm_based_retrieval" class="item"><strong>For Basic VSM-Based Retrieval:</strong></a></strong></dt>

<dd>
<p>For basic VSM-based model construction and retrieval, run the script:</p>
<pre>
    retrieve_with_VSM.pl</pre>
</dd>
<dt><strong><a name="for_basic_lsa_based_retrieval" class="item"><strong>For Basic LSA-Based Retrieval:</strong></a></strong></dt>

<dd>
<p>For basic LSA-based model construction and retrieval, run the script:</p>
<pre>
    retrieve_with_LSA.pl</pre>
<p>Both of the above scripts will store the corpus models created
in disk-based databases.</p>
</dd>
<dt><strong><a name="for_vsm_based_retrieval_with_a_disk_stored_model" class="item"><strong>For VSM-Based Retrieval with a Disk-Stored Model:</strong></a></strong></dt>

<dd>
<p>If you have previously run a script like <code>retrieve_with_VSM.pl</code> and
no intervening code has modified the disk-stored VSM model of the corpus,
you can run the script</p>
<pre>
    retrieve_with_disk_based_VSM.pl</pre>
<p>This would obviously work faster at retrieval since the VSM model would NOT
need to constructed for each new query.</p>
</dd>
<dt><strong><a name="for_lsa_based_retrieval_with_a_disk_stored_model" class="item"><strong>For LSA-Based Retrieval with a Disk-Stored Model:</strong></a></strong></dt>

<dd>
<p>If you have previously run a script like <code>retrieve_with_LSA.pl</code> and
no intervening code has modified the disk-stored LSA model of the corpus,
you can run the script</p>
<pre>
    retrieve_with_disk_based_LSA.pl</pre>
<p>The retrieval performance of such a script would be faster since the LSA
model would NOT need to constructed for each new query.</p>
</dd>
<dt><strong><a name="for_precision_and_recall_calculations_with_vsm" class="item"><strong>For Precision and Recall Calculations with VSM:</strong></a></strong></dt>

<dd>
<p>To experiment with precision and recall calculations for VSM retrieval,
run the script:</p>
<pre>
    calculate_precision_and_recall_for_VSM.pl</pre>
<p>Note that this script will carry out its own estimation of relevancy
judgments --- which in most cases would not be a safe thing to do.</p>
</dd>
<dt><strong><a name="for_precision_and_recall_calculations_with_lsa" class="item"><strong>For Precision and Recall Calculations with LSA:</strong></a></strong></dt>

<dd>
<p>To experiment with precision and recall calculations for LSA retrieval,
run the script:</p>
<pre>
    calculate_precision_and_recall_for_LSA.pl</pre>
<p>Note that this script will carry out its own estimation of relevancy
judgments --- which in most cases would not be a safe thing to do.</p>
</dd>
<dt><strong><a name="for_precision_and_recall_calculations_for_vsm_with_human_supplied_relevancies" class="item"><strong>For Precision and Recall Calculations for VSM with
Human-Supplied Relevancies:</strong></a></strong></dt>

<dd>
<p>Precision and recall calculations for retrieval accuracy determination are
best carried out with human-supplied judgments of relevancies of the
documents to queries.  If such judgments are available, run the
script:</p>
<pre>
    calculate_precision_and_recall_from_file_based_relevancies_for_VSM.pl</pre>
<p>This script will print out the average precisions for the different test
queries and calculate the MAP metric of retrieval accuracy.</p>
</dd>
<dt><strong><a name="for_precision_and_recall_calculations_for_lsa_with_human_supplied_relevancies" class="item"><strong>For Precision and Recall Calculations for LSA with
Human-Supplied Relevancies:</strong></a></strong></dt>

<dd>
<p>If human-supplied relevancy judgments are available and you wish to
experiment with precision and recall calculations for LSA-based retrieval,
run the script:</p>
<pre>
    calculate_precision_and_recall_from_file_based_relevancies_for_LSA.pl</pre>
<p>This script will print out the average precisions for the different test
queries and calculate the MAP metric of retrieval accuracy.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="export">EXPORT</a></h1>
<p>None by design.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Please notify the author if you encounter any bugs.  When sending email,
please place the string 'VSM' in the subject line to get past my spam
filter.</p>
<p>
</p>
<hr />
<h1><a name="installation">INSTALLATION</a></h1>
<p>The usual</p>
<pre>
    perl Makefile.PL
    make
    make test
    make install</pre>
<p>if you have root access.  If not,</p>
<pre>
    perl Makefile.PL prefix=/some/other/directory/
    make
    make test
    make install</pre>
<p>
</p>
<hr />
<h1><a name="thanks">THANKS</a></h1>
<p>Many thanks are owed to Shivani Rao for sharing with me her
deep insights in IR-based retrieval.  She was also of much
help with the debugging of this module by bringing to bear
on its output her amazing software forensic skills.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Avinash Kak, <a href="mailto:kak@purdue.edu">kak@purdue.edu</a></p>
<p>If you send email, please place the string &quot;VSM&quot; in your
subject line to get past my spam filter.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</p>
<pre>
 Copyright 2011 Avinash Kak</pre>

</body>

</html>
